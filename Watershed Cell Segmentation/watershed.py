# -*- coding: utf-8 -*-
"""Lab7_Template.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17flDXvSeo7gVA4F1yQkg4OCgteCRwaDD
"""

!wget -q -nc https://raw.githubusercontent.com/pseprivamirakbarnejad/cmput206lab/master/Lab7/lab7.bmp
!wget -q -nc https://raw.githubusercontent.com/pseprivamirakbarnejad/cmput206lab/master/Lab7/lab7_part1.txt
!wget -q -nc https://raw.githubusercontent.com/pseprivamirakbarnejad/cmput206lab/master/Lab7/blob_markers.txt
!ls

import numpy as np

def getSmallestNeighborIndex(img, row, col):
    min_row_id = -1
    min_col_id = -1
    min_val = np.inf
    h, w = img.shape
    for row_id in range(row - 1, row + 2):
        if row_id < 0 or row_id >= h:
            continue
        for col_id in range(col - 1, col + 2):
            if col_id < 0 or col_id >= w:
                continue
            if row_id == row and col_id == col:
                continue
            if img[row_id, col_id] < min_val:
                min_row_id = row_id
                min_col_id = col_id
                min_val = img[row_id, col_id]
    return min_row_id, min_col_id


def getRegionalMinima(img):
    regional_minima = np.zeros(img.shape, dtype=np.int32)
    h, w = img.shape
    index = 1

    for y in range(h):
      for x in range(w):
        minimum_y,minimum_x = getSmallestNeighborIndex(img, y, x)
        
        if img[y][x] <= img[minimum_y][minimum_x]:
          regional_minima[y][x] = index
          index += 1
    return regional_minima


    


def iterativeMinFollowing(img, markers):
    markers_copy = np.copy(markers)
    h, w = img.shape
    while True:
        #Your code here
        n_unmarked_pix = 0
        for i in range(h):
          for j in range(w):
            minimum_y,minimum_x = getSmallestNeighborIndex(img, i, j)
            if markers_copy[i][j] > 0:
              pass

            elif markers_copy[minimum_y][minimum_x] > 0:
              markers_copy[i][j] = markers_copy[minimum_y][minimum_x]

            elif markers_copy[i][j] ==0:
              n_unmarked_pix += 1
        print ('n_unmarked_pix: ', n_unmarked_pix)
        if n_unmarked_pix == 0:
          break
        
    return markers_copy

test_image = np.loadtxt('lab7_part1.txt')
print("test_image\n", test_image)
markers = getRegionalMinima(test_image)
print("markers\n", markers)
labels = iterativeMinFollowing(test_image, markers)
print("labels\n", labels)

import numpy as np
import cv2
import matplotlib.pyplot as plt
from skimage import io
import skimage
from skimage.measure import find_contours


def imreconstruct(marker, mask):
    curr_marker = (np.copy(marker)).astype(mask.dtype)
    kernel = np.ones([3, 3])
    while True:
        next_marker = cv2.dilate(curr_marker, kernel, iterations=1)
        intersection = next_marker > mask
        next_marker[intersection] = mask[intersection]
        if np.array_equal(next_marker, curr_marker):
          return curr_marker
        else:
          curr_marker = np.copy(next_marker)

    return curr_marker


def imimposemin(marker, mask):
    # adapted from its namesake in MATLAB
    fm = np.copy(mask)
    fm[marker] = -np.inf
    fm[np.invert(marker)] = np.inf
    if mask.dtype == np.float32 or mask.dtype == np.float64:
        range = float(np.max(mask) - np.min(mask))
        if range == 0:
            h = 0.1
        else:
            h = range * 0.001
    else:
        # Add 1 to integer images.
        h = 1
    fp1 = mask + h
    g = np.minimum(fp1, fm)#If marker:-inf. Else:(||grad||+h)
    return np.invert(imreconstruct(
        np.invert(fm.astype(np.uint8)), np.invert(g.astype(np.uint8))
    ).astype(np.uint8))

sigma = 2.5
img_name = 'lab7.bmp'
img_rgb = io.imread(img_name).astype(np.float32)
img_gs = skimage.color.rgb2gray(img_rgb)

img_blurred = cv2.GaussianBlur(img_gs, (int(2 * round(3 * sigma) + 1), int(2 * round(3 * sigma) + 1)), sigma
                     )#borderType=cv2.BORDER_REPLICATE

[img_grad_y, img_grad_x] = np.gradient(img_blurred)
img_grad = np.square(img_grad_x) + np.square(img_grad_y)

# refined blob locations generated generated in part 3 of lab 6
blob_markers = np.loadtxt('blob_markers.txt', dtype=np.bool, delimiter='\t')

img_grad_min_imposed = imimposemin(blob_markers, img_grad)

markers = getRegionalMinima(img_grad_min_imposed)
plt.figure(0)
plt.imshow(markers,cmap='jet')
plt.title('markers')

labels = iterativeMinFollowing(img_grad_min_imposed, np.copy(markers))
plt.figure(1)
plt.imshow(labels,cmap='jet')
plt.title('labels')

#contour of img_grad_min_imposed
contours = find_contours(img_grad_min_imposed, 0.8)



fig,ax=plt.subplots()
ax.imshow(img_grad_min_imposed, interpolation='nearest', cmap=plt.cm.gray)#
for n, contour in enumerate(contours):
    ax.plot(contour[:, 1], contour[:, 0], linewidth=2)



ax.axis('image')
ax.set_xticks([])
ax.set_yticks([])
plt.show()

